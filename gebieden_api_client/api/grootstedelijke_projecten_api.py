# coding: utf-8

"""
    gebieden

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Contact: datapunt@amsterdam.nl
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from gebieden_api_client.models.gebiedengrootstedelijke_projecten import GebiedengrootstedelijkeProjecten
from gebieden_api_client.models.paginated_gebiedengrootstedelijke_projecten_list import PaginatedGebiedengrootstedelijkeProjectenList

from gebieden_api_client.api_client import ApiClient, RequestSerialized
from gebieden_api_client.api_response import ApiResponse
from gebieden_api_client.rest import RESTResponseType


class GrootstedelijkeProjectenApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def gebieden_grootstedelijke_projecten_list(
        self,
        accept_crs: Annotated[Optional[StrictStr], Field(description="Accept-Crs header for Geo queries")] = None,
        content_crs: Annotated[Optional[StrictStr], Field(description="Content-Crs header for Geo queries")] = None,
        x_api_key: Annotated[Optional[StrictStr], Field(description="Api Key for statistical purposes, not for authentication")] = None,
        count: Annotated[Optional[StrictBool], Field(description="Include a count of the total result set and the number of pages.Only works for responses that return a page.")] = None,
        expand: Annotated[Optional[StrictBool], Field(description="Allow to expand relations.")] = None,
        expand_scope: Annotated[Optional[StrictStr], Field(description="Comma separated list of named relations to expand.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields to display")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Select the export format")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        datum: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        datum_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        datum_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        datum_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        datum_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        datum_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        geometrie: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        geometrie_contains: Annotated[Optional[StrictStr], Field(description="Use x,y or POINT(x y)")] = None,
        geometrie_intersects: Annotated[Optional[StrictStr], Field(description="Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON")] = None,
        geometrie_isnull: Annotated[Optional[StrictStr], Field(description="Whether the field has a NULL value or not.")] = None,
        geometrie_not: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        id: Annotated[Optional[StrictInt], Field(description="Exact; number")] = None,
        id_gt: Annotated[Optional[StrictInt], Field(description="Greater than; number")] = None,
        id_gte: Annotated[Optional[StrictInt], Field(description="Greater than or equal to; number")] = None,
        id_in: Annotated[Optional[List[StrictInt]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        id_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        id_lt: Annotated[Optional[StrictInt], Field(description="Less than; number")] = None,
        id_lte: Annotated[Optional[StrictInt], Field(description="Less than or equal to; number")] = None,
        id_not: Annotated[Optional[List[StrictInt]], Field(description="Exclude matches; number")] = None,
        legenda: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        legenda_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        legenda_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        legenda_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        legenda_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        legenda_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        naam: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        naam_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        naam_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        naam_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        naam_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        naam_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        page: Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Categorie GSP, OD, PHS of PHSOD")] = None,
        type_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        type_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        type_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        type_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        type_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        typering: Annotated[Optional[StrictStr], Field(description="Omschrijving type")] = None,
        typering_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        typering_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        typering_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        typering_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        typering_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        url: Annotated[Optional[StrictStr], Field(description="URL naar bekendmaking")] = None,
        url_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        url_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        url_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        url_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        url_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; URL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedGebiedengrootstedelijkeProjectenList:
        """gebieden_grootstedelijke_projecten_list


        :param accept_crs: Accept-Crs header for Geo queries
        :type accept_crs: str
        :param content_crs: Content-Crs header for Geo queries
        :type content_crs: str
        :param x_api_key: Api Key for statistical purposes, not for authentication
        :type x_api_key: str
        :param count: Include a count of the total result set and the number of pages.Only works for responses that return a page.
        :type count: bool
        :param expand: Allow to expand relations.
        :type expand: bool
        :param expand_scope: Comma separated list of named relations to expand.
        :type expand_scope: str
        :param fields: Comma-separated list of fields to display
        :type fields: str
        :param format: Select the export format
        :type format: str
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param sort: Which field to use when ordering the results.
        :type sort: str
        :param datum: Exact; text
        :type datum: str
        :param datum_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type datum_in: List[str]
        :param datum_isempty: Whether the field is empty or not.
        :type datum_isempty: bool
        :param datum_isnull: Whether the field has a NULL value or not.
        :type datum_isnull: bool
        :param datum_like: Matches text using wildcards (? and *).
        :type datum_like: str
        :param datum_not: Exclude matches; text
        :type datum_not: List[str]
        :param geometrie: GeoJSON | GEOMETRY(...)
        :type geometrie: str
        :param geometrie_contains: Use x,y or POINT(x y)
        :type geometrie_contains: str
        :param geometrie_intersects: Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON
        :type geometrie_intersects: str
        :param geometrie_isnull: Whether the field has a NULL value or not.
        :type geometrie_isnull: str
        :param geometrie_not: GeoJSON | GEOMETRY(...)
        :type geometrie_not: str
        :param id: Exact; number
        :type id: int
        :param id_gt: Greater than; number
        :type id_gt: int
        :param id_gte: Greater than or equal to; number
        :type id_gte: int
        :param id_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type id_in: List[int]
        :param id_isnull: Whether the field has a NULL value or not.
        :type id_isnull: bool
        :param id_lt: Less than; number
        :type id_lt: int
        :param id_lte: Less than or equal to; number
        :type id_lte: int
        :param id_not: Exclude matches; number
        :type id_not: List[int]
        :param legenda: Exact; text
        :type legenda: str
        :param legenda_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type legenda_in: List[str]
        :param legenda_isempty: Whether the field is empty or not.
        :type legenda_isempty: bool
        :param legenda_isnull: Whether the field has a NULL value or not.
        :type legenda_isnull: bool
        :param legenda_like: Matches text using wildcards (? and *).
        :type legenda_like: str
        :param legenda_not: Exclude matches; text
        :type legenda_not: List[str]
        :param naam: Exact; text
        :type naam: str
        :param naam_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type naam_in: List[str]
        :param naam_isempty: Whether the field is empty or not.
        :type naam_isempty: bool
        :param naam_isnull: Whether the field has a NULL value or not.
        :type naam_isnull: bool
        :param naam_like: Matches text using wildcards (? and *).
        :type naam_like: str
        :param naam_not: Exclude matches; text
        :type naam_not: List[str]
        :param page: A page number within the paginated result set.
        :type page: int
        :param type: Categorie GSP, OD, PHS of PHSOD
        :type type: str
        :param type_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type type_in: List[str]
        :param type_isempty: Whether the field is empty or not.
        :type type_isempty: bool
        :param type_isnull: Whether the field has a NULL value or not.
        :type type_isnull: bool
        :param type_like: Matches text using wildcards (? and *).
        :type type_like: str
        :param type_not: Exclude matches; text
        :type type_not: List[str]
        :param typering: Omschrijving type
        :type typering: str
        :param typering_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type typering_in: List[str]
        :param typering_isempty: Whether the field is empty or not.
        :type typering_isempty: bool
        :param typering_isnull: Whether the field has a NULL value or not.
        :type typering_isnull: bool
        :param typering_like: Matches text using wildcards (? and *).
        :type typering_like: str
        :param typering_not: Exclude matches; text
        :type typering_not: List[str]
        :param url: URL naar bekendmaking
        :type url: str
        :param url_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type url_in: List[str]
        :param url_isempty: Whether the field is empty or not.
        :type url_isempty: bool
        :param url_isnull: Whether the field has a NULL value or not.
        :type url_isnull: bool
        :param url_like: Matches text using wildcards (? and *).
        :type url_like: str
        :param url_not: Exclude matches; URL
        :type url_not: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gebieden_grootstedelijke_projecten_list_serialize(
            accept_crs=accept_crs,
            content_crs=content_crs,
            x_api_key=x_api_key,
            count=count,
            expand=expand,
            expand_scope=expand_scope,
            fields=fields,
            format=format,
            page_size=page_size,
            sort=sort,
            datum=datum,
            datum_in=datum_in,
            datum_isempty=datum_isempty,
            datum_isnull=datum_isnull,
            datum_like=datum_like,
            datum_not=datum_not,
            geometrie=geometrie,
            geometrie_contains=geometrie_contains,
            geometrie_intersects=geometrie_intersects,
            geometrie_isnull=geometrie_isnull,
            geometrie_not=geometrie_not,
            id=id,
            id_gt=id_gt,
            id_gte=id_gte,
            id_in=id_in,
            id_isnull=id_isnull,
            id_lt=id_lt,
            id_lte=id_lte,
            id_not=id_not,
            legenda=legenda,
            legenda_in=legenda_in,
            legenda_isempty=legenda_isempty,
            legenda_isnull=legenda_isnull,
            legenda_like=legenda_like,
            legenda_not=legenda_not,
            naam=naam,
            naam_in=naam_in,
            naam_isempty=naam_isempty,
            naam_isnull=naam_isnull,
            naam_like=naam_like,
            naam_not=naam_not,
            page=page,
            type=type,
            type_in=type_in,
            type_isempty=type_isempty,
            type_isnull=type_isnull,
            type_like=type_like,
            type_not=type_not,
            typering=typering,
            typering_in=typering_in,
            typering_isempty=typering_isempty,
            typering_isnull=typering_isnull,
            typering_like=typering_like,
            typering_not=typering_not,
            url=url,
            url_in=url_in,
            url_isempty=url_isempty,
            url_isnull=url_isnull,
            url_like=url_like,
            url_not=url_not,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedGebiedengrootstedelijkeProjectenList",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def gebieden_grootstedelijke_projecten_list_with_http_info(
        self,
        accept_crs: Annotated[Optional[StrictStr], Field(description="Accept-Crs header for Geo queries")] = None,
        content_crs: Annotated[Optional[StrictStr], Field(description="Content-Crs header for Geo queries")] = None,
        x_api_key: Annotated[Optional[StrictStr], Field(description="Api Key for statistical purposes, not for authentication")] = None,
        count: Annotated[Optional[StrictBool], Field(description="Include a count of the total result set and the number of pages.Only works for responses that return a page.")] = None,
        expand: Annotated[Optional[StrictBool], Field(description="Allow to expand relations.")] = None,
        expand_scope: Annotated[Optional[StrictStr], Field(description="Comma separated list of named relations to expand.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields to display")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Select the export format")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        datum: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        datum_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        datum_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        datum_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        datum_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        datum_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        geometrie: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        geometrie_contains: Annotated[Optional[StrictStr], Field(description="Use x,y or POINT(x y)")] = None,
        geometrie_intersects: Annotated[Optional[StrictStr], Field(description="Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON")] = None,
        geometrie_isnull: Annotated[Optional[StrictStr], Field(description="Whether the field has a NULL value or not.")] = None,
        geometrie_not: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        id: Annotated[Optional[StrictInt], Field(description="Exact; number")] = None,
        id_gt: Annotated[Optional[StrictInt], Field(description="Greater than; number")] = None,
        id_gte: Annotated[Optional[StrictInt], Field(description="Greater than or equal to; number")] = None,
        id_in: Annotated[Optional[List[StrictInt]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        id_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        id_lt: Annotated[Optional[StrictInt], Field(description="Less than; number")] = None,
        id_lte: Annotated[Optional[StrictInt], Field(description="Less than or equal to; number")] = None,
        id_not: Annotated[Optional[List[StrictInt]], Field(description="Exclude matches; number")] = None,
        legenda: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        legenda_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        legenda_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        legenda_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        legenda_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        legenda_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        naam: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        naam_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        naam_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        naam_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        naam_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        naam_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        page: Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Categorie GSP, OD, PHS of PHSOD")] = None,
        type_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        type_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        type_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        type_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        type_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        typering: Annotated[Optional[StrictStr], Field(description="Omschrijving type")] = None,
        typering_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        typering_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        typering_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        typering_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        typering_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        url: Annotated[Optional[StrictStr], Field(description="URL naar bekendmaking")] = None,
        url_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        url_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        url_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        url_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        url_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; URL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedGebiedengrootstedelijkeProjectenList]:
        """gebieden_grootstedelijke_projecten_list


        :param accept_crs: Accept-Crs header for Geo queries
        :type accept_crs: str
        :param content_crs: Content-Crs header for Geo queries
        :type content_crs: str
        :param x_api_key: Api Key for statistical purposes, not for authentication
        :type x_api_key: str
        :param count: Include a count of the total result set and the number of pages.Only works for responses that return a page.
        :type count: bool
        :param expand: Allow to expand relations.
        :type expand: bool
        :param expand_scope: Comma separated list of named relations to expand.
        :type expand_scope: str
        :param fields: Comma-separated list of fields to display
        :type fields: str
        :param format: Select the export format
        :type format: str
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param sort: Which field to use when ordering the results.
        :type sort: str
        :param datum: Exact; text
        :type datum: str
        :param datum_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type datum_in: List[str]
        :param datum_isempty: Whether the field is empty or not.
        :type datum_isempty: bool
        :param datum_isnull: Whether the field has a NULL value or not.
        :type datum_isnull: bool
        :param datum_like: Matches text using wildcards (? and *).
        :type datum_like: str
        :param datum_not: Exclude matches; text
        :type datum_not: List[str]
        :param geometrie: GeoJSON | GEOMETRY(...)
        :type geometrie: str
        :param geometrie_contains: Use x,y or POINT(x y)
        :type geometrie_contains: str
        :param geometrie_intersects: Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON
        :type geometrie_intersects: str
        :param geometrie_isnull: Whether the field has a NULL value or not.
        :type geometrie_isnull: str
        :param geometrie_not: GeoJSON | GEOMETRY(...)
        :type geometrie_not: str
        :param id: Exact; number
        :type id: int
        :param id_gt: Greater than; number
        :type id_gt: int
        :param id_gte: Greater than or equal to; number
        :type id_gte: int
        :param id_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type id_in: List[int]
        :param id_isnull: Whether the field has a NULL value or not.
        :type id_isnull: bool
        :param id_lt: Less than; number
        :type id_lt: int
        :param id_lte: Less than or equal to; number
        :type id_lte: int
        :param id_not: Exclude matches; number
        :type id_not: List[int]
        :param legenda: Exact; text
        :type legenda: str
        :param legenda_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type legenda_in: List[str]
        :param legenda_isempty: Whether the field is empty or not.
        :type legenda_isempty: bool
        :param legenda_isnull: Whether the field has a NULL value or not.
        :type legenda_isnull: bool
        :param legenda_like: Matches text using wildcards (? and *).
        :type legenda_like: str
        :param legenda_not: Exclude matches; text
        :type legenda_not: List[str]
        :param naam: Exact; text
        :type naam: str
        :param naam_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type naam_in: List[str]
        :param naam_isempty: Whether the field is empty or not.
        :type naam_isempty: bool
        :param naam_isnull: Whether the field has a NULL value or not.
        :type naam_isnull: bool
        :param naam_like: Matches text using wildcards (? and *).
        :type naam_like: str
        :param naam_not: Exclude matches; text
        :type naam_not: List[str]
        :param page: A page number within the paginated result set.
        :type page: int
        :param type: Categorie GSP, OD, PHS of PHSOD
        :type type: str
        :param type_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type type_in: List[str]
        :param type_isempty: Whether the field is empty or not.
        :type type_isempty: bool
        :param type_isnull: Whether the field has a NULL value or not.
        :type type_isnull: bool
        :param type_like: Matches text using wildcards (? and *).
        :type type_like: str
        :param type_not: Exclude matches; text
        :type type_not: List[str]
        :param typering: Omschrijving type
        :type typering: str
        :param typering_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type typering_in: List[str]
        :param typering_isempty: Whether the field is empty or not.
        :type typering_isempty: bool
        :param typering_isnull: Whether the field has a NULL value or not.
        :type typering_isnull: bool
        :param typering_like: Matches text using wildcards (? and *).
        :type typering_like: str
        :param typering_not: Exclude matches; text
        :type typering_not: List[str]
        :param url: URL naar bekendmaking
        :type url: str
        :param url_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type url_in: List[str]
        :param url_isempty: Whether the field is empty or not.
        :type url_isempty: bool
        :param url_isnull: Whether the field has a NULL value or not.
        :type url_isnull: bool
        :param url_like: Matches text using wildcards (? and *).
        :type url_like: str
        :param url_not: Exclude matches; URL
        :type url_not: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gebieden_grootstedelijke_projecten_list_serialize(
            accept_crs=accept_crs,
            content_crs=content_crs,
            x_api_key=x_api_key,
            count=count,
            expand=expand,
            expand_scope=expand_scope,
            fields=fields,
            format=format,
            page_size=page_size,
            sort=sort,
            datum=datum,
            datum_in=datum_in,
            datum_isempty=datum_isempty,
            datum_isnull=datum_isnull,
            datum_like=datum_like,
            datum_not=datum_not,
            geometrie=geometrie,
            geometrie_contains=geometrie_contains,
            geometrie_intersects=geometrie_intersects,
            geometrie_isnull=geometrie_isnull,
            geometrie_not=geometrie_not,
            id=id,
            id_gt=id_gt,
            id_gte=id_gte,
            id_in=id_in,
            id_isnull=id_isnull,
            id_lt=id_lt,
            id_lte=id_lte,
            id_not=id_not,
            legenda=legenda,
            legenda_in=legenda_in,
            legenda_isempty=legenda_isempty,
            legenda_isnull=legenda_isnull,
            legenda_like=legenda_like,
            legenda_not=legenda_not,
            naam=naam,
            naam_in=naam_in,
            naam_isempty=naam_isempty,
            naam_isnull=naam_isnull,
            naam_like=naam_like,
            naam_not=naam_not,
            page=page,
            type=type,
            type_in=type_in,
            type_isempty=type_isempty,
            type_isnull=type_isnull,
            type_like=type_like,
            type_not=type_not,
            typering=typering,
            typering_in=typering_in,
            typering_isempty=typering_isempty,
            typering_isnull=typering_isnull,
            typering_like=typering_like,
            typering_not=typering_not,
            url=url,
            url_in=url_in,
            url_isempty=url_isempty,
            url_isnull=url_isnull,
            url_like=url_like,
            url_not=url_not,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedGebiedengrootstedelijkeProjectenList",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def gebieden_grootstedelijke_projecten_list_without_preload_content(
        self,
        accept_crs: Annotated[Optional[StrictStr], Field(description="Accept-Crs header for Geo queries")] = None,
        content_crs: Annotated[Optional[StrictStr], Field(description="Content-Crs header for Geo queries")] = None,
        x_api_key: Annotated[Optional[StrictStr], Field(description="Api Key for statistical purposes, not for authentication")] = None,
        count: Annotated[Optional[StrictBool], Field(description="Include a count of the total result set and the number of pages.Only works for responses that return a page.")] = None,
        expand: Annotated[Optional[StrictBool], Field(description="Allow to expand relations.")] = None,
        expand_scope: Annotated[Optional[StrictStr], Field(description="Comma separated list of named relations to expand.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields to display")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Select the export format")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        datum: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        datum_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        datum_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        datum_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        datum_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        datum_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        geometrie: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        geometrie_contains: Annotated[Optional[StrictStr], Field(description="Use x,y or POINT(x y)")] = None,
        geometrie_intersects: Annotated[Optional[StrictStr], Field(description="Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON")] = None,
        geometrie_isnull: Annotated[Optional[StrictStr], Field(description="Whether the field has a NULL value or not.")] = None,
        geometrie_not: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        id: Annotated[Optional[StrictInt], Field(description="Exact; number")] = None,
        id_gt: Annotated[Optional[StrictInt], Field(description="Greater than; number")] = None,
        id_gte: Annotated[Optional[StrictInt], Field(description="Greater than or equal to; number")] = None,
        id_in: Annotated[Optional[List[StrictInt]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        id_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        id_lt: Annotated[Optional[StrictInt], Field(description="Less than; number")] = None,
        id_lte: Annotated[Optional[StrictInt], Field(description="Less than or equal to; number")] = None,
        id_not: Annotated[Optional[List[StrictInt]], Field(description="Exclude matches; number")] = None,
        legenda: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        legenda_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        legenda_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        legenda_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        legenda_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        legenda_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        naam: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        naam_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        naam_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        naam_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        naam_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        naam_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        page: Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Categorie GSP, OD, PHS of PHSOD")] = None,
        type_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        type_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        type_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        type_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        type_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        typering: Annotated[Optional[StrictStr], Field(description="Omschrijving type")] = None,
        typering_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        typering_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        typering_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        typering_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        typering_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        url: Annotated[Optional[StrictStr], Field(description="URL naar bekendmaking")] = None,
        url_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        url_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        url_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        url_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        url_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; URL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """gebieden_grootstedelijke_projecten_list


        :param accept_crs: Accept-Crs header for Geo queries
        :type accept_crs: str
        :param content_crs: Content-Crs header for Geo queries
        :type content_crs: str
        :param x_api_key: Api Key for statistical purposes, not for authentication
        :type x_api_key: str
        :param count: Include a count of the total result set and the number of pages.Only works for responses that return a page.
        :type count: bool
        :param expand: Allow to expand relations.
        :type expand: bool
        :param expand_scope: Comma separated list of named relations to expand.
        :type expand_scope: str
        :param fields: Comma-separated list of fields to display
        :type fields: str
        :param format: Select the export format
        :type format: str
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param sort: Which field to use when ordering the results.
        :type sort: str
        :param datum: Exact; text
        :type datum: str
        :param datum_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type datum_in: List[str]
        :param datum_isempty: Whether the field is empty or not.
        :type datum_isempty: bool
        :param datum_isnull: Whether the field has a NULL value or not.
        :type datum_isnull: bool
        :param datum_like: Matches text using wildcards (? and *).
        :type datum_like: str
        :param datum_not: Exclude matches; text
        :type datum_not: List[str]
        :param geometrie: GeoJSON | GEOMETRY(...)
        :type geometrie: str
        :param geometrie_contains: Use x,y or POINT(x y)
        :type geometrie_contains: str
        :param geometrie_intersects: Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON
        :type geometrie_intersects: str
        :param geometrie_isnull: Whether the field has a NULL value or not.
        :type geometrie_isnull: str
        :param geometrie_not: GeoJSON | GEOMETRY(...)
        :type geometrie_not: str
        :param id: Exact; number
        :type id: int
        :param id_gt: Greater than; number
        :type id_gt: int
        :param id_gte: Greater than or equal to; number
        :type id_gte: int
        :param id_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type id_in: List[int]
        :param id_isnull: Whether the field has a NULL value or not.
        :type id_isnull: bool
        :param id_lt: Less than; number
        :type id_lt: int
        :param id_lte: Less than or equal to; number
        :type id_lte: int
        :param id_not: Exclude matches; number
        :type id_not: List[int]
        :param legenda: Exact; text
        :type legenda: str
        :param legenda_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type legenda_in: List[str]
        :param legenda_isempty: Whether the field is empty or not.
        :type legenda_isempty: bool
        :param legenda_isnull: Whether the field has a NULL value or not.
        :type legenda_isnull: bool
        :param legenda_like: Matches text using wildcards (? and *).
        :type legenda_like: str
        :param legenda_not: Exclude matches; text
        :type legenda_not: List[str]
        :param naam: Exact; text
        :type naam: str
        :param naam_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type naam_in: List[str]
        :param naam_isempty: Whether the field is empty or not.
        :type naam_isempty: bool
        :param naam_isnull: Whether the field has a NULL value or not.
        :type naam_isnull: bool
        :param naam_like: Matches text using wildcards (? and *).
        :type naam_like: str
        :param naam_not: Exclude matches; text
        :type naam_not: List[str]
        :param page: A page number within the paginated result set.
        :type page: int
        :param type: Categorie GSP, OD, PHS of PHSOD
        :type type: str
        :param type_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type type_in: List[str]
        :param type_isempty: Whether the field is empty or not.
        :type type_isempty: bool
        :param type_isnull: Whether the field has a NULL value or not.
        :type type_isnull: bool
        :param type_like: Matches text using wildcards (? and *).
        :type type_like: str
        :param type_not: Exclude matches; text
        :type type_not: List[str]
        :param typering: Omschrijving type
        :type typering: str
        :param typering_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type typering_in: List[str]
        :param typering_isempty: Whether the field is empty or not.
        :type typering_isempty: bool
        :param typering_isnull: Whether the field has a NULL value or not.
        :type typering_isnull: bool
        :param typering_like: Matches text using wildcards (? and *).
        :type typering_like: str
        :param typering_not: Exclude matches; text
        :type typering_not: List[str]
        :param url: URL naar bekendmaking
        :type url: str
        :param url_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type url_in: List[str]
        :param url_isempty: Whether the field is empty or not.
        :type url_isempty: bool
        :param url_isnull: Whether the field has a NULL value or not.
        :type url_isnull: bool
        :param url_like: Matches text using wildcards (? and *).
        :type url_like: str
        :param url_not: Exclude matches; URL
        :type url_not: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gebieden_grootstedelijke_projecten_list_serialize(
            accept_crs=accept_crs,
            content_crs=content_crs,
            x_api_key=x_api_key,
            count=count,
            expand=expand,
            expand_scope=expand_scope,
            fields=fields,
            format=format,
            page_size=page_size,
            sort=sort,
            datum=datum,
            datum_in=datum_in,
            datum_isempty=datum_isempty,
            datum_isnull=datum_isnull,
            datum_like=datum_like,
            datum_not=datum_not,
            geometrie=geometrie,
            geometrie_contains=geometrie_contains,
            geometrie_intersects=geometrie_intersects,
            geometrie_isnull=geometrie_isnull,
            geometrie_not=geometrie_not,
            id=id,
            id_gt=id_gt,
            id_gte=id_gte,
            id_in=id_in,
            id_isnull=id_isnull,
            id_lt=id_lt,
            id_lte=id_lte,
            id_not=id_not,
            legenda=legenda,
            legenda_in=legenda_in,
            legenda_isempty=legenda_isempty,
            legenda_isnull=legenda_isnull,
            legenda_like=legenda_like,
            legenda_not=legenda_not,
            naam=naam,
            naam_in=naam_in,
            naam_isempty=naam_isempty,
            naam_isnull=naam_isnull,
            naam_like=naam_like,
            naam_not=naam_not,
            page=page,
            type=type,
            type_in=type_in,
            type_isempty=type_isempty,
            type_isnull=type_isnull,
            type_like=type_like,
            type_not=type_not,
            typering=typering,
            typering_in=typering_in,
            typering_isempty=typering_isempty,
            typering_isnull=typering_isnull,
            typering_like=typering_like,
            typering_not=typering_not,
            url=url,
            url_in=url_in,
            url_isempty=url_isempty,
            url_isnull=url_isnull,
            url_like=url_like,
            url_not=url_not,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedGebiedengrootstedelijkeProjectenList",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _gebieden_grootstedelijke_projecten_list_serialize(
        self,
        accept_crs,
        content_crs,
        x_api_key,
        count,
        expand,
        expand_scope,
        fields,
        format,
        page_size,
        sort,
        datum,
        datum_in,
        datum_isempty,
        datum_isnull,
        datum_like,
        datum_not,
        geometrie,
        geometrie_contains,
        geometrie_intersects,
        geometrie_isnull,
        geometrie_not,
        id,
        id_gt,
        id_gte,
        id_in,
        id_isnull,
        id_lt,
        id_lte,
        id_not,
        legenda,
        legenda_in,
        legenda_isempty,
        legenda_isnull,
        legenda_like,
        legenda_not,
        naam,
        naam_in,
        naam_isempty,
        naam_isnull,
        naam_like,
        naam_not,
        page,
        type,
        type_in,
        type_isempty,
        type_isnull,
        type_like,
        type_not,
        typering,
        typering_in,
        typering_isempty,
        typering_isnull,
        typering_like,
        typering_not,
        url,
        url_in,
        url_isempty,
        url_isnull,
        url_like,
        url_not,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'datum[in]': 'csv',
            'datum[not]': 'multi',
            'id[in]': 'csv',
            'id[not]': 'multi',
            'legenda[in]': 'csv',
            'legenda[not]': 'multi',
            'naam[in]': 'csv',
            'naam[not]': 'multi',
            'type[in]': 'csv',
            'type[not]': 'multi',
            'typering[in]': 'csv',
            'typering[not]': 'multi',
            'url[in]': 'csv',
            'url[not]': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if count is not None:
            
            _query_params.append(('_count', count))
            
        if expand is not None:
            
            _query_params.append(('_expand', expand))
            
        if expand_scope is not None:
            
            _query_params.append(('_expandScope', expand_scope))
            
        if fields is not None:
            
            _query_params.append(('_fields', fields))
            
        if format is not None:
            
            _query_params.append(('_format', format))
            
        if page_size is not None:
            
            _query_params.append(('_pageSize', page_size))
            
        if sort is not None:
            
            _query_params.append(('_sort', sort))
            
        if datum is not None:
            
            _query_params.append(('datum', datum))
            
        if datum_in is not None:
            
            _query_params.append(('datum[in]', datum_in))
            
        if datum_isempty is not None:
            
            _query_params.append(('datum[isempty]', datum_isempty))
            
        if datum_isnull is not None:
            
            _query_params.append(('datum[isnull]', datum_isnull))
            
        if datum_like is not None:
            
            _query_params.append(('datum[like]', datum_like))
            
        if datum_not is not None:
            
            _query_params.append(('datum[not]', datum_not))
            
        if geometrie is not None:
            
            _query_params.append(('geometrie', geometrie))
            
        if geometrie_contains is not None:
            
            _query_params.append(('geometrie[contains]', geometrie_contains))
            
        if geometrie_intersects is not None:
            
            _query_params.append(('geometrie[intersects]', geometrie_intersects))
            
        if geometrie_isnull is not None:
            
            _query_params.append(('geometrie[isnull]', geometrie_isnull))
            
        if geometrie_not is not None:
            
            _query_params.append(('geometrie[not]', geometrie_not))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        if id_gt is not None:
            
            _query_params.append(('id[gt]', id_gt))
            
        if id_gte is not None:
            
            _query_params.append(('id[gte]', id_gte))
            
        if id_in is not None:
            
            _query_params.append(('id[in]', id_in))
            
        if id_isnull is not None:
            
            _query_params.append(('id[isnull]', id_isnull))
            
        if id_lt is not None:
            
            _query_params.append(('id[lt]', id_lt))
            
        if id_lte is not None:
            
            _query_params.append(('id[lte]', id_lte))
            
        if id_not is not None:
            
            _query_params.append(('id[not]', id_not))
            
        if legenda is not None:
            
            _query_params.append(('legenda', legenda))
            
        if legenda_in is not None:
            
            _query_params.append(('legenda[in]', legenda_in))
            
        if legenda_isempty is not None:
            
            _query_params.append(('legenda[isempty]', legenda_isempty))
            
        if legenda_isnull is not None:
            
            _query_params.append(('legenda[isnull]', legenda_isnull))
            
        if legenda_like is not None:
            
            _query_params.append(('legenda[like]', legenda_like))
            
        if legenda_not is not None:
            
            _query_params.append(('legenda[not]', legenda_not))
            
        if naam is not None:
            
            _query_params.append(('naam', naam))
            
        if naam_in is not None:
            
            _query_params.append(('naam[in]', naam_in))
            
        if naam_isempty is not None:
            
            _query_params.append(('naam[isempty]', naam_isempty))
            
        if naam_isnull is not None:
            
            _query_params.append(('naam[isnull]', naam_isnull))
            
        if naam_like is not None:
            
            _query_params.append(('naam[like]', naam_like))
            
        if naam_not is not None:
            
            _query_params.append(('naam[not]', naam_not))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if type_in is not None:
            
            _query_params.append(('type[in]', type_in))
            
        if type_isempty is not None:
            
            _query_params.append(('type[isempty]', type_isempty))
            
        if type_isnull is not None:
            
            _query_params.append(('type[isnull]', type_isnull))
            
        if type_like is not None:
            
            _query_params.append(('type[like]', type_like))
            
        if type_not is not None:
            
            _query_params.append(('type[not]', type_not))
            
        if typering is not None:
            
            _query_params.append(('typering', typering))
            
        if typering_in is not None:
            
            _query_params.append(('typering[in]', typering_in))
            
        if typering_isempty is not None:
            
            _query_params.append(('typering[isempty]', typering_isempty))
            
        if typering_isnull is not None:
            
            _query_params.append(('typering[isnull]', typering_isnull))
            
        if typering_like is not None:
            
            _query_params.append(('typering[like]', typering_like))
            
        if typering_not is not None:
            
            _query_params.append(('typering[not]', typering_not))
            
        if url is not None:
            
            _query_params.append(('url', url))
            
        if url_in is not None:
            
            _query_params.append(('url[in]', url_in))
            
        if url_isempty is not None:
            
            _query_params.append(('url[isempty]', url_isempty))
            
        if url_isnull is not None:
            
            _query_params.append(('url[isnull]', url_isnull))
            
        if url_like is not None:
            
            _query_params.append(('url[like]', url_like))
            
        if url_not is not None:
            
            _query_params.append(('url[not]', url_not))
            
        # process the header parameters
        if accept_crs is not None:
            _header_params['Accept-Crs'] = accept_crs
        if content_crs is not None:
            _header_params['Content-Crs'] = content_crs
        if x_api_key is not None:
            _header_params['X-Api-Key'] = x_api_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/hal+json', 
                    'text/csv', 
                    'application/geo+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/gebieden/grootstedelijke_projecten/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def gebieden_grootstedelijke_projecten_retrieve(
        self,
        id: Annotated[str, Field(strict=True)],
        accept_crs: Annotated[Optional[StrictStr], Field(description="Accept-Crs header for Geo queries")] = None,
        content_crs: Annotated[Optional[StrictStr], Field(description="Content-Crs header for Geo queries")] = None,
        x_api_key: Annotated[Optional[StrictStr], Field(description="Api Key for statistical purposes, not for authentication")] = None,
        expand: Annotated[Optional[StrictBool], Field(description="Allow to expand relations.")] = None,
        expand_scope: Annotated[Optional[StrictStr], Field(description="Comma separated list of named relations to expand.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields to display")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Select the export format")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        datum: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        datum_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        datum_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        datum_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        datum_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        datum_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        geometrie: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        geometrie_contains: Annotated[Optional[StrictStr], Field(description="Use x,y or POINT(x y)")] = None,
        geometrie_intersects: Annotated[Optional[StrictStr], Field(description="Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON")] = None,
        geometrie_isnull: Annotated[Optional[StrictStr], Field(description="Whether the field has a NULL value or not.")] = None,
        geometrie_not: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        id2: Annotated[Optional[StrictInt], Field(description="Exact; number")] = None,
        id_gt: Annotated[Optional[StrictInt], Field(description="Greater than; number")] = None,
        id_gte: Annotated[Optional[StrictInt], Field(description="Greater than or equal to; number")] = None,
        id_in: Annotated[Optional[List[StrictInt]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        id_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        id_lt: Annotated[Optional[StrictInt], Field(description="Less than; number")] = None,
        id_lte: Annotated[Optional[StrictInt], Field(description="Less than or equal to; number")] = None,
        id_not: Annotated[Optional[List[StrictInt]], Field(description="Exclude matches; number")] = None,
        legenda: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        legenda_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        legenda_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        legenda_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        legenda_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        legenda_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        naam: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        naam_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        naam_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        naam_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        naam_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        naam_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Categorie GSP, OD, PHS of PHSOD")] = None,
        type_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        type_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        type_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        type_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        type_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        typering: Annotated[Optional[StrictStr], Field(description="Omschrijving type")] = None,
        typering_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        typering_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        typering_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        typering_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        typering_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        url: Annotated[Optional[StrictStr], Field(description="URL naar bekendmaking")] = None,
        url_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        url_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        url_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        url_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        url_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; URL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GebiedengrootstedelijkeProjecten:
        """gebieden_grootstedelijke_projecten_retrieve


        :param id: (required)
        :type id: str
        :param accept_crs: Accept-Crs header for Geo queries
        :type accept_crs: str
        :param content_crs: Content-Crs header for Geo queries
        :type content_crs: str
        :param x_api_key: Api Key for statistical purposes, not for authentication
        :type x_api_key: str
        :param expand: Allow to expand relations.
        :type expand: bool
        :param expand_scope: Comma separated list of named relations to expand.
        :type expand_scope: str
        :param fields: Comma-separated list of fields to display
        :type fields: str
        :param format: Select the export format
        :type format: str
        :param sort: Which field to use when ordering the results.
        :type sort: str
        :param datum: Exact; text
        :type datum: str
        :param datum_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type datum_in: List[str]
        :param datum_isempty: Whether the field is empty or not.
        :type datum_isempty: bool
        :param datum_isnull: Whether the field has a NULL value or not.
        :type datum_isnull: bool
        :param datum_like: Matches text using wildcards (? and *).
        :type datum_like: str
        :param datum_not: Exclude matches; text
        :type datum_not: List[str]
        :param geometrie: GeoJSON | GEOMETRY(...)
        :type geometrie: str
        :param geometrie_contains: Use x,y or POINT(x y)
        :type geometrie_contains: str
        :param geometrie_intersects: Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON
        :type geometrie_intersects: str
        :param geometrie_isnull: Whether the field has a NULL value or not.
        :type geometrie_isnull: str
        :param geometrie_not: GeoJSON | GEOMETRY(...)
        :type geometrie_not: str
        :param id2: Exact; number
        :type id2: int
        :param id_gt: Greater than; number
        :type id_gt: int
        :param id_gte: Greater than or equal to; number
        :type id_gte: int
        :param id_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type id_in: List[int]
        :param id_isnull: Whether the field has a NULL value or not.
        :type id_isnull: bool
        :param id_lt: Less than; number
        :type id_lt: int
        :param id_lte: Less than or equal to; number
        :type id_lte: int
        :param id_not: Exclude matches; number
        :type id_not: List[int]
        :param legenda: Exact; text
        :type legenda: str
        :param legenda_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type legenda_in: List[str]
        :param legenda_isempty: Whether the field is empty or not.
        :type legenda_isempty: bool
        :param legenda_isnull: Whether the field has a NULL value or not.
        :type legenda_isnull: bool
        :param legenda_like: Matches text using wildcards (? and *).
        :type legenda_like: str
        :param legenda_not: Exclude matches; text
        :type legenda_not: List[str]
        :param naam: Exact; text
        :type naam: str
        :param naam_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type naam_in: List[str]
        :param naam_isempty: Whether the field is empty or not.
        :type naam_isempty: bool
        :param naam_isnull: Whether the field has a NULL value or not.
        :type naam_isnull: bool
        :param naam_like: Matches text using wildcards (? and *).
        :type naam_like: str
        :param naam_not: Exclude matches; text
        :type naam_not: List[str]
        :param type: Categorie GSP, OD, PHS of PHSOD
        :type type: str
        :param type_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type type_in: List[str]
        :param type_isempty: Whether the field is empty or not.
        :type type_isempty: bool
        :param type_isnull: Whether the field has a NULL value or not.
        :type type_isnull: bool
        :param type_like: Matches text using wildcards (? and *).
        :type type_like: str
        :param type_not: Exclude matches; text
        :type type_not: List[str]
        :param typering: Omschrijving type
        :type typering: str
        :param typering_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type typering_in: List[str]
        :param typering_isempty: Whether the field is empty or not.
        :type typering_isempty: bool
        :param typering_isnull: Whether the field has a NULL value or not.
        :type typering_isnull: bool
        :param typering_like: Matches text using wildcards (? and *).
        :type typering_like: str
        :param typering_not: Exclude matches; text
        :type typering_not: List[str]
        :param url: URL naar bekendmaking
        :type url: str
        :param url_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type url_in: List[str]
        :param url_isempty: Whether the field is empty or not.
        :type url_isempty: bool
        :param url_isnull: Whether the field has a NULL value or not.
        :type url_isnull: bool
        :param url_like: Matches text using wildcards (? and *).
        :type url_like: str
        :param url_not: Exclude matches; URL
        :type url_not: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gebieden_grootstedelijke_projecten_retrieve_serialize(
            id=id,
            accept_crs=accept_crs,
            content_crs=content_crs,
            x_api_key=x_api_key,
            expand=expand,
            expand_scope=expand_scope,
            fields=fields,
            format=format,
            sort=sort,
            datum=datum,
            datum_in=datum_in,
            datum_isempty=datum_isempty,
            datum_isnull=datum_isnull,
            datum_like=datum_like,
            datum_not=datum_not,
            geometrie=geometrie,
            geometrie_contains=geometrie_contains,
            geometrie_intersects=geometrie_intersects,
            geometrie_isnull=geometrie_isnull,
            geometrie_not=geometrie_not,
            id2=id2,
            id_gt=id_gt,
            id_gte=id_gte,
            id_in=id_in,
            id_isnull=id_isnull,
            id_lt=id_lt,
            id_lte=id_lte,
            id_not=id_not,
            legenda=legenda,
            legenda_in=legenda_in,
            legenda_isempty=legenda_isempty,
            legenda_isnull=legenda_isnull,
            legenda_like=legenda_like,
            legenda_not=legenda_not,
            naam=naam,
            naam_in=naam_in,
            naam_isempty=naam_isempty,
            naam_isnull=naam_isnull,
            naam_like=naam_like,
            naam_not=naam_not,
            type=type,
            type_in=type_in,
            type_isempty=type_isempty,
            type_isnull=type_isnull,
            type_like=type_like,
            type_not=type_not,
            typering=typering,
            typering_in=typering_in,
            typering_isempty=typering_isempty,
            typering_isnull=typering_isnull,
            typering_like=typering_like,
            typering_not=typering_not,
            url=url,
            url_in=url_in,
            url_isempty=url_isempty,
            url_isnull=url_isnull,
            url_like=url_like,
            url_not=url_not,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GebiedengrootstedelijkeProjecten",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def gebieden_grootstedelijke_projecten_retrieve_with_http_info(
        self,
        id: Annotated[str, Field(strict=True)],
        accept_crs: Annotated[Optional[StrictStr], Field(description="Accept-Crs header for Geo queries")] = None,
        content_crs: Annotated[Optional[StrictStr], Field(description="Content-Crs header for Geo queries")] = None,
        x_api_key: Annotated[Optional[StrictStr], Field(description="Api Key for statistical purposes, not for authentication")] = None,
        expand: Annotated[Optional[StrictBool], Field(description="Allow to expand relations.")] = None,
        expand_scope: Annotated[Optional[StrictStr], Field(description="Comma separated list of named relations to expand.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields to display")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Select the export format")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        datum: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        datum_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        datum_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        datum_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        datum_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        datum_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        geometrie: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        geometrie_contains: Annotated[Optional[StrictStr], Field(description="Use x,y or POINT(x y)")] = None,
        geometrie_intersects: Annotated[Optional[StrictStr], Field(description="Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON")] = None,
        geometrie_isnull: Annotated[Optional[StrictStr], Field(description="Whether the field has a NULL value or not.")] = None,
        geometrie_not: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        id2: Annotated[Optional[StrictInt], Field(description="Exact; number")] = None,
        id_gt: Annotated[Optional[StrictInt], Field(description="Greater than; number")] = None,
        id_gte: Annotated[Optional[StrictInt], Field(description="Greater than or equal to; number")] = None,
        id_in: Annotated[Optional[List[StrictInt]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        id_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        id_lt: Annotated[Optional[StrictInt], Field(description="Less than; number")] = None,
        id_lte: Annotated[Optional[StrictInt], Field(description="Less than or equal to; number")] = None,
        id_not: Annotated[Optional[List[StrictInt]], Field(description="Exclude matches; number")] = None,
        legenda: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        legenda_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        legenda_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        legenda_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        legenda_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        legenda_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        naam: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        naam_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        naam_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        naam_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        naam_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        naam_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Categorie GSP, OD, PHS of PHSOD")] = None,
        type_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        type_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        type_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        type_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        type_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        typering: Annotated[Optional[StrictStr], Field(description="Omschrijving type")] = None,
        typering_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        typering_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        typering_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        typering_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        typering_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        url: Annotated[Optional[StrictStr], Field(description="URL naar bekendmaking")] = None,
        url_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        url_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        url_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        url_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        url_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; URL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GebiedengrootstedelijkeProjecten]:
        """gebieden_grootstedelijke_projecten_retrieve


        :param id: (required)
        :type id: str
        :param accept_crs: Accept-Crs header for Geo queries
        :type accept_crs: str
        :param content_crs: Content-Crs header for Geo queries
        :type content_crs: str
        :param x_api_key: Api Key for statistical purposes, not for authentication
        :type x_api_key: str
        :param expand: Allow to expand relations.
        :type expand: bool
        :param expand_scope: Comma separated list of named relations to expand.
        :type expand_scope: str
        :param fields: Comma-separated list of fields to display
        :type fields: str
        :param format: Select the export format
        :type format: str
        :param sort: Which field to use when ordering the results.
        :type sort: str
        :param datum: Exact; text
        :type datum: str
        :param datum_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type datum_in: List[str]
        :param datum_isempty: Whether the field is empty or not.
        :type datum_isempty: bool
        :param datum_isnull: Whether the field has a NULL value or not.
        :type datum_isnull: bool
        :param datum_like: Matches text using wildcards (? and *).
        :type datum_like: str
        :param datum_not: Exclude matches; text
        :type datum_not: List[str]
        :param geometrie: GeoJSON | GEOMETRY(...)
        :type geometrie: str
        :param geometrie_contains: Use x,y or POINT(x y)
        :type geometrie_contains: str
        :param geometrie_intersects: Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON
        :type geometrie_intersects: str
        :param geometrie_isnull: Whether the field has a NULL value or not.
        :type geometrie_isnull: str
        :param geometrie_not: GeoJSON | GEOMETRY(...)
        :type geometrie_not: str
        :param id2: Exact; number
        :type id2: int
        :param id_gt: Greater than; number
        :type id_gt: int
        :param id_gte: Greater than or equal to; number
        :type id_gte: int
        :param id_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type id_in: List[int]
        :param id_isnull: Whether the field has a NULL value or not.
        :type id_isnull: bool
        :param id_lt: Less than; number
        :type id_lt: int
        :param id_lte: Less than or equal to; number
        :type id_lte: int
        :param id_not: Exclude matches; number
        :type id_not: List[int]
        :param legenda: Exact; text
        :type legenda: str
        :param legenda_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type legenda_in: List[str]
        :param legenda_isempty: Whether the field is empty or not.
        :type legenda_isempty: bool
        :param legenda_isnull: Whether the field has a NULL value or not.
        :type legenda_isnull: bool
        :param legenda_like: Matches text using wildcards (? and *).
        :type legenda_like: str
        :param legenda_not: Exclude matches; text
        :type legenda_not: List[str]
        :param naam: Exact; text
        :type naam: str
        :param naam_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type naam_in: List[str]
        :param naam_isempty: Whether the field is empty or not.
        :type naam_isempty: bool
        :param naam_isnull: Whether the field has a NULL value or not.
        :type naam_isnull: bool
        :param naam_like: Matches text using wildcards (? and *).
        :type naam_like: str
        :param naam_not: Exclude matches; text
        :type naam_not: List[str]
        :param type: Categorie GSP, OD, PHS of PHSOD
        :type type: str
        :param type_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type type_in: List[str]
        :param type_isempty: Whether the field is empty or not.
        :type type_isempty: bool
        :param type_isnull: Whether the field has a NULL value or not.
        :type type_isnull: bool
        :param type_like: Matches text using wildcards (? and *).
        :type type_like: str
        :param type_not: Exclude matches; text
        :type type_not: List[str]
        :param typering: Omschrijving type
        :type typering: str
        :param typering_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type typering_in: List[str]
        :param typering_isempty: Whether the field is empty or not.
        :type typering_isempty: bool
        :param typering_isnull: Whether the field has a NULL value or not.
        :type typering_isnull: bool
        :param typering_like: Matches text using wildcards (? and *).
        :type typering_like: str
        :param typering_not: Exclude matches; text
        :type typering_not: List[str]
        :param url: URL naar bekendmaking
        :type url: str
        :param url_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type url_in: List[str]
        :param url_isempty: Whether the field is empty or not.
        :type url_isempty: bool
        :param url_isnull: Whether the field has a NULL value or not.
        :type url_isnull: bool
        :param url_like: Matches text using wildcards (? and *).
        :type url_like: str
        :param url_not: Exclude matches; URL
        :type url_not: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gebieden_grootstedelijke_projecten_retrieve_serialize(
            id=id,
            accept_crs=accept_crs,
            content_crs=content_crs,
            x_api_key=x_api_key,
            expand=expand,
            expand_scope=expand_scope,
            fields=fields,
            format=format,
            sort=sort,
            datum=datum,
            datum_in=datum_in,
            datum_isempty=datum_isempty,
            datum_isnull=datum_isnull,
            datum_like=datum_like,
            datum_not=datum_not,
            geometrie=geometrie,
            geometrie_contains=geometrie_contains,
            geometrie_intersects=geometrie_intersects,
            geometrie_isnull=geometrie_isnull,
            geometrie_not=geometrie_not,
            id2=id2,
            id_gt=id_gt,
            id_gte=id_gte,
            id_in=id_in,
            id_isnull=id_isnull,
            id_lt=id_lt,
            id_lte=id_lte,
            id_not=id_not,
            legenda=legenda,
            legenda_in=legenda_in,
            legenda_isempty=legenda_isempty,
            legenda_isnull=legenda_isnull,
            legenda_like=legenda_like,
            legenda_not=legenda_not,
            naam=naam,
            naam_in=naam_in,
            naam_isempty=naam_isempty,
            naam_isnull=naam_isnull,
            naam_like=naam_like,
            naam_not=naam_not,
            type=type,
            type_in=type_in,
            type_isempty=type_isempty,
            type_isnull=type_isnull,
            type_like=type_like,
            type_not=type_not,
            typering=typering,
            typering_in=typering_in,
            typering_isempty=typering_isempty,
            typering_isnull=typering_isnull,
            typering_like=typering_like,
            typering_not=typering_not,
            url=url,
            url_in=url_in,
            url_isempty=url_isempty,
            url_isnull=url_isnull,
            url_like=url_like,
            url_not=url_not,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GebiedengrootstedelijkeProjecten",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def gebieden_grootstedelijke_projecten_retrieve_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True)],
        accept_crs: Annotated[Optional[StrictStr], Field(description="Accept-Crs header for Geo queries")] = None,
        content_crs: Annotated[Optional[StrictStr], Field(description="Content-Crs header for Geo queries")] = None,
        x_api_key: Annotated[Optional[StrictStr], Field(description="Api Key for statistical purposes, not for authentication")] = None,
        expand: Annotated[Optional[StrictBool], Field(description="Allow to expand relations.")] = None,
        expand_scope: Annotated[Optional[StrictStr], Field(description="Comma separated list of named relations to expand.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields to display")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Select the export format")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        datum: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        datum_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        datum_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        datum_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        datum_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        datum_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        geometrie: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        geometrie_contains: Annotated[Optional[StrictStr], Field(description="Use x,y or POINT(x y)")] = None,
        geometrie_intersects: Annotated[Optional[StrictStr], Field(description="Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON")] = None,
        geometrie_isnull: Annotated[Optional[StrictStr], Field(description="Whether the field has a NULL value or not.")] = None,
        geometrie_not: Annotated[Optional[StrictStr], Field(description="GeoJSON | GEOMETRY(...)")] = None,
        id2: Annotated[Optional[StrictInt], Field(description="Exact; number")] = None,
        id_gt: Annotated[Optional[StrictInt], Field(description="Greater than; number")] = None,
        id_gte: Annotated[Optional[StrictInt], Field(description="Greater than or equal to; number")] = None,
        id_in: Annotated[Optional[List[StrictInt]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        id_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        id_lt: Annotated[Optional[StrictInt], Field(description="Less than; number")] = None,
        id_lte: Annotated[Optional[StrictInt], Field(description="Less than or equal to; number")] = None,
        id_not: Annotated[Optional[List[StrictInt]], Field(description="Exclude matches; number")] = None,
        legenda: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        legenda_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        legenda_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        legenda_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        legenda_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        legenda_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        naam: Annotated[Optional[StrictStr], Field(description="Exact; text")] = None,
        naam_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        naam_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        naam_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        naam_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        naam_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Categorie GSP, OD, PHS of PHSOD")] = None,
        type_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        type_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        type_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        type_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        type_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        typering: Annotated[Optional[StrictStr], Field(description="Omschrijving type")] = None,
        typering_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        typering_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        typering_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        typering_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        typering_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; text")] = None,
        url: Annotated[Optional[StrictStr], Field(description="URL naar bekendmaking")] = None,
        url_in: Annotated[Optional[List[StrictStr]], Field(description="Matches any value from a comma-separated list: val1,val2,valN.")] = None,
        url_isempty: Annotated[Optional[StrictBool], Field(description="Whether the field is empty or not.")] = None,
        url_isnull: Annotated[Optional[StrictBool], Field(description="Whether the field has a NULL value or not.")] = None,
        url_like: Annotated[Optional[StrictStr], Field(description="Matches text using wildcards (? and *).")] = None,
        url_not: Annotated[Optional[List[StrictStr]], Field(description="Exclude matches; URL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """gebieden_grootstedelijke_projecten_retrieve


        :param id: (required)
        :type id: str
        :param accept_crs: Accept-Crs header for Geo queries
        :type accept_crs: str
        :param content_crs: Content-Crs header for Geo queries
        :type content_crs: str
        :param x_api_key: Api Key for statistical purposes, not for authentication
        :type x_api_key: str
        :param expand: Allow to expand relations.
        :type expand: bool
        :param expand_scope: Comma separated list of named relations to expand.
        :type expand_scope: str
        :param fields: Comma-separated list of fields to display
        :type fields: str
        :param format: Select the export format
        :type format: str
        :param sort: Which field to use when ordering the results.
        :type sort: str
        :param datum: Exact; text
        :type datum: str
        :param datum_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type datum_in: List[str]
        :param datum_isempty: Whether the field is empty or not.
        :type datum_isempty: bool
        :param datum_isnull: Whether the field has a NULL value or not.
        :type datum_isnull: bool
        :param datum_like: Matches text using wildcards (? and *).
        :type datum_like: str
        :param datum_not: Exclude matches; text
        :type datum_not: List[str]
        :param geometrie: GeoJSON | GEOMETRY(...)
        :type geometrie: str
        :param geometrie_contains: Use x,y or POINT(x y)
        :type geometrie_contains: str
        :param geometrie_intersects: Use WKT (POLYGON((x1 y1, x2 y2, ...))) or GeoJSON
        :type geometrie_intersects: str
        :param geometrie_isnull: Whether the field has a NULL value or not.
        :type geometrie_isnull: str
        :param geometrie_not: GeoJSON | GEOMETRY(...)
        :type geometrie_not: str
        :param id2: Exact; number
        :type id2: int
        :param id_gt: Greater than; number
        :type id_gt: int
        :param id_gte: Greater than or equal to; number
        :type id_gte: int
        :param id_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type id_in: List[int]
        :param id_isnull: Whether the field has a NULL value or not.
        :type id_isnull: bool
        :param id_lt: Less than; number
        :type id_lt: int
        :param id_lte: Less than or equal to; number
        :type id_lte: int
        :param id_not: Exclude matches; number
        :type id_not: List[int]
        :param legenda: Exact; text
        :type legenda: str
        :param legenda_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type legenda_in: List[str]
        :param legenda_isempty: Whether the field is empty or not.
        :type legenda_isempty: bool
        :param legenda_isnull: Whether the field has a NULL value or not.
        :type legenda_isnull: bool
        :param legenda_like: Matches text using wildcards (? and *).
        :type legenda_like: str
        :param legenda_not: Exclude matches; text
        :type legenda_not: List[str]
        :param naam: Exact; text
        :type naam: str
        :param naam_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type naam_in: List[str]
        :param naam_isempty: Whether the field is empty or not.
        :type naam_isempty: bool
        :param naam_isnull: Whether the field has a NULL value or not.
        :type naam_isnull: bool
        :param naam_like: Matches text using wildcards (? and *).
        :type naam_like: str
        :param naam_not: Exclude matches; text
        :type naam_not: List[str]
        :param type: Categorie GSP, OD, PHS of PHSOD
        :type type: str
        :param type_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type type_in: List[str]
        :param type_isempty: Whether the field is empty or not.
        :type type_isempty: bool
        :param type_isnull: Whether the field has a NULL value or not.
        :type type_isnull: bool
        :param type_like: Matches text using wildcards (? and *).
        :type type_like: str
        :param type_not: Exclude matches; text
        :type type_not: List[str]
        :param typering: Omschrijving type
        :type typering: str
        :param typering_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type typering_in: List[str]
        :param typering_isempty: Whether the field is empty or not.
        :type typering_isempty: bool
        :param typering_isnull: Whether the field has a NULL value or not.
        :type typering_isnull: bool
        :param typering_like: Matches text using wildcards (? and *).
        :type typering_like: str
        :param typering_not: Exclude matches; text
        :type typering_not: List[str]
        :param url: URL naar bekendmaking
        :type url: str
        :param url_in: Matches any value from a comma-separated list: val1,val2,valN.
        :type url_in: List[str]
        :param url_isempty: Whether the field is empty or not.
        :type url_isempty: bool
        :param url_isnull: Whether the field has a NULL value or not.
        :type url_isnull: bool
        :param url_like: Matches text using wildcards (? and *).
        :type url_like: str
        :param url_not: Exclude matches; URL
        :type url_not: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gebieden_grootstedelijke_projecten_retrieve_serialize(
            id=id,
            accept_crs=accept_crs,
            content_crs=content_crs,
            x_api_key=x_api_key,
            expand=expand,
            expand_scope=expand_scope,
            fields=fields,
            format=format,
            sort=sort,
            datum=datum,
            datum_in=datum_in,
            datum_isempty=datum_isempty,
            datum_isnull=datum_isnull,
            datum_like=datum_like,
            datum_not=datum_not,
            geometrie=geometrie,
            geometrie_contains=geometrie_contains,
            geometrie_intersects=geometrie_intersects,
            geometrie_isnull=geometrie_isnull,
            geometrie_not=geometrie_not,
            id2=id2,
            id_gt=id_gt,
            id_gte=id_gte,
            id_in=id_in,
            id_isnull=id_isnull,
            id_lt=id_lt,
            id_lte=id_lte,
            id_not=id_not,
            legenda=legenda,
            legenda_in=legenda_in,
            legenda_isempty=legenda_isempty,
            legenda_isnull=legenda_isnull,
            legenda_like=legenda_like,
            legenda_not=legenda_not,
            naam=naam,
            naam_in=naam_in,
            naam_isempty=naam_isempty,
            naam_isnull=naam_isnull,
            naam_like=naam_like,
            naam_not=naam_not,
            type=type,
            type_in=type_in,
            type_isempty=type_isempty,
            type_isnull=type_isnull,
            type_like=type_like,
            type_not=type_not,
            typering=typering,
            typering_in=typering_in,
            typering_isempty=typering_isempty,
            typering_isnull=typering_isnull,
            typering_like=typering_like,
            typering_not=typering_not,
            url=url,
            url_in=url_in,
            url_isempty=url_isempty,
            url_isnull=url_isnull,
            url_like=url_like,
            url_not=url_not,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GebiedengrootstedelijkeProjecten",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _gebieden_grootstedelijke_projecten_retrieve_serialize(
        self,
        id,
        accept_crs,
        content_crs,
        x_api_key,
        expand,
        expand_scope,
        fields,
        format,
        sort,
        datum,
        datum_in,
        datum_isempty,
        datum_isnull,
        datum_like,
        datum_not,
        geometrie,
        geometrie_contains,
        geometrie_intersects,
        geometrie_isnull,
        geometrie_not,
        id2,
        id_gt,
        id_gte,
        id_in,
        id_isnull,
        id_lt,
        id_lte,
        id_not,
        legenda,
        legenda_in,
        legenda_isempty,
        legenda_isnull,
        legenda_like,
        legenda_not,
        naam,
        naam_in,
        naam_isempty,
        naam_isnull,
        naam_like,
        naam_not,
        type,
        type_in,
        type_isempty,
        type_isnull,
        type_like,
        type_not,
        typering,
        typering_in,
        typering_isempty,
        typering_isnull,
        typering_like,
        typering_not,
        url,
        url_in,
        url_isempty,
        url_isnull,
        url_like,
        url_not,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'datum[in]': 'csv',
            'datum[not]': 'multi',
            'id[in]': 'csv',
            'id[not]': 'multi',
            'legenda[in]': 'csv',
            'legenda[not]': 'multi',
            'naam[in]': 'csv',
            'naam[not]': 'multi',
            'type[in]': 'csv',
            'type[not]': 'multi',
            'typering[in]': 'csv',
            'typering[not]': 'multi',
            'url[in]': 'csv',
            'url[not]': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if expand is not None:
            
            _query_params.append(('_expand', expand))
            
        if expand_scope is not None:
            
            _query_params.append(('_expandScope', expand_scope))
            
        if fields is not None:
            
            _query_params.append(('_fields', fields))
            
        if format is not None:
            
            _query_params.append(('_format', format))
            
        if sort is not None:
            
            _query_params.append(('_sort', sort))
            
        if datum is not None:
            
            _query_params.append(('datum', datum))
            
        if datum_in is not None:
            
            _query_params.append(('datum[in]', datum_in))
            
        if datum_isempty is not None:
            
            _query_params.append(('datum[isempty]', datum_isempty))
            
        if datum_isnull is not None:
            
            _query_params.append(('datum[isnull]', datum_isnull))
            
        if datum_like is not None:
            
            _query_params.append(('datum[like]', datum_like))
            
        if datum_not is not None:
            
            _query_params.append(('datum[not]', datum_not))
            
        if geometrie is not None:
            
            _query_params.append(('geometrie', geometrie))
            
        if geometrie_contains is not None:
            
            _query_params.append(('geometrie[contains]', geometrie_contains))
            
        if geometrie_intersects is not None:
            
            _query_params.append(('geometrie[intersects]', geometrie_intersects))
            
        if geometrie_isnull is not None:
            
            _query_params.append(('geometrie[isnull]', geometrie_isnull))
            
        if geometrie_not is not None:
            
            _query_params.append(('geometrie[not]', geometrie_not))
            
        if id2 is not None:
            
            _query_params.append(('id', id2))
            
        if id_gt is not None:
            
            _query_params.append(('id[gt]', id_gt))
            
        if id_gte is not None:
            
            _query_params.append(('id[gte]', id_gte))
            
        if id_in is not None:
            
            _query_params.append(('id[in]', id_in))
            
        if id_isnull is not None:
            
            _query_params.append(('id[isnull]', id_isnull))
            
        if id_lt is not None:
            
            _query_params.append(('id[lt]', id_lt))
            
        if id_lte is not None:
            
            _query_params.append(('id[lte]', id_lte))
            
        if id_not is not None:
            
            _query_params.append(('id[not]', id_not))
            
        if legenda is not None:
            
            _query_params.append(('legenda', legenda))
            
        if legenda_in is not None:
            
            _query_params.append(('legenda[in]', legenda_in))
            
        if legenda_isempty is not None:
            
            _query_params.append(('legenda[isempty]', legenda_isempty))
            
        if legenda_isnull is not None:
            
            _query_params.append(('legenda[isnull]', legenda_isnull))
            
        if legenda_like is not None:
            
            _query_params.append(('legenda[like]', legenda_like))
            
        if legenda_not is not None:
            
            _query_params.append(('legenda[not]', legenda_not))
            
        if naam is not None:
            
            _query_params.append(('naam', naam))
            
        if naam_in is not None:
            
            _query_params.append(('naam[in]', naam_in))
            
        if naam_isempty is not None:
            
            _query_params.append(('naam[isempty]', naam_isempty))
            
        if naam_isnull is not None:
            
            _query_params.append(('naam[isnull]', naam_isnull))
            
        if naam_like is not None:
            
            _query_params.append(('naam[like]', naam_like))
            
        if naam_not is not None:
            
            _query_params.append(('naam[not]', naam_not))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if type_in is not None:
            
            _query_params.append(('type[in]', type_in))
            
        if type_isempty is not None:
            
            _query_params.append(('type[isempty]', type_isempty))
            
        if type_isnull is not None:
            
            _query_params.append(('type[isnull]', type_isnull))
            
        if type_like is not None:
            
            _query_params.append(('type[like]', type_like))
            
        if type_not is not None:
            
            _query_params.append(('type[not]', type_not))
            
        if typering is not None:
            
            _query_params.append(('typering', typering))
            
        if typering_in is not None:
            
            _query_params.append(('typering[in]', typering_in))
            
        if typering_isempty is not None:
            
            _query_params.append(('typering[isempty]', typering_isempty))
            
        if typering_isnull is not None:
            
            _query_params.append(('typering[isnull]', typering_isnull))
            
        if typering_like is not None:
            
            _query_params.append(('typering[like]', typering_like))
            
        if typering_not is not None:
            
            _query_params.append(('typering[not]', typering_not))
            
        if url is not None:
            
            _query_params.append(('url', url))
            
        if url_in is not None:
            
            _query_params.append(('url[in]', url_in))
            
        if url_isempty is not None:
            
            _query_params.append(('url[isempty]', url_isempty))
            
        if url_isnull is not None:
            
            _query_params.append(('url[isnull]', url_isnull))
            
        if url_like is not None:
            
            _query_params.append(('url[like]', url_like))
            
        if url_not is not None:
            
            _query_params.append(('url[not]', url_not))
            
        # process the header parameters
        if accept_crs is not None:
            _header_params['Accept-Crs'] = accept_crs
        if content_crs is not None:
            _header_params['Content-Crs'] = content_crs
        if x_api_key is not None:
            _header_params['X-Api-Key'] = x_api_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/hal+json', 
                    'text/csv', 
                    'application/geo+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/gebieden/grootstedelijke_projecten/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


